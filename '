using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.InputSystem;

public class PlayerAttackScript : MonoBehaviour
{
	#region Attack Fields
	[Header("Attack Properties")]
	//Attack duration
	public float AttackDuration = 0.5f;
	private float _currentAttackTime;
	private bool _attacking;
	private float _attackCompletion
	{
		get { return _currentAttackTime / AttackDuration; }
	}
	private Vector2 _mostRecentAttackDirection;

	//Attack Cooldown
	public float AttackCooldownDuration = 2f;
	private float _currentAttackCooldownTime;
	private bool _attackReady
	{
		get { return _currentAttackCooldownTime == 0f; }
	}
	#endregion

	#region Spell Fields
	/**  
	 *	SPELLS EXPLANATION
	 *	
	 *		In order to cast a spell, a specific combination of attacks must happen.
	 *	 This combination is able to happen without waiting for the cooldown on weapons,
	 *   so it's not locked by the _attackReady boolean.
	 *   
	 *   In order to implement this, I will be creating a resettable STRING which will 
	 *   consist of characters based on the inputs:
	 *   
	 *   L - Left click (Slash)
	 *   R - Right click (Thrust)
	 *   S - Spacebar (Slam)
	 *   
	 *   In the update method, I will be constantly checking if the string has a preset
	 *   spell input, and if it does, the spell will be cast and the string reset. 
	 */

	/**  
	 *	SPELL FIELDS
	 *	
	 *		The spell fields will consist of preset strings and the changeable 
	 *		string for the current "cast". 
	 */
	public string FireballSpell = "LLL";
	public string LightningStreamSpell = "RRR";
	public string IceHailRainSpell = "SSS";
	public string WaterSwordSpell = "LSL";
	public string WaterPiercingRainSpell = "SLS";
	public string WaterBlastSpell = "LLS";
	public string SnowStormSpell = "SSL";
	public string FireArrowSpell = "LLR";
	public string LightningBoltSpell = "RRL";

	public List<string> spellList = new List<string>();
	public Dictionary<string, string> spellDictionary = new Dictionary<string, string>();
	public bool Castable;

	private bool _spellBeingInputted;
	private bool _spellFinished;

	public string currentSpellCast;


	//Cooldown on spells 
	public float SpellInputDuration = 4f;
	public float spellInputTimer;
	public bool isSpellActive => spellInputTimer > 0f;
	#endregion

	#region Sword Drawing
	[Range(0f, 360f)] public int SlashArc;
	private Vector3 _slashArcOffset
	{
		get { return new Vector3(0, 0, SlashArc / 2); }
	}
	private Vector3 _slashArcBegin;
	private Vector3 _slashArcEnd;

	private GameObject _swordControlPoint;
	#endregion

	// Start is called before the first frame update
	void Start()
	{
		#region Sword Initialization
		_swordControlPoint = gameObject.transform.GetChild(0).gameObject;
		_swordControlPoint.SetActive(false);
		#endregion

		#region Spell Initialization
		currentSpellCast = "";
		spellList.Add(FireballSpell);
		spellList.Add(LightningStreamSpell);
		spellList.Add(IceHailRainSpell);
		spellList.Add(WaterSwordSpell);
		spellList.Add(WaterPiercingRainSpell);
		spellList.Add(WaterBlastSpell);
		spellList.Add(SnowStormSpell);
		spellList.Add(FireArrowSpell);
		spellList.Add(LightningBoltSpell);
		Castable = false;
		_spellBeingInputted = false;
		#endregion

	}

	// Update is called once per frame
	void Update()
	{
		#region Sword update
		//Tick attack cooldown if possible and not attacking.
		if (!_attacking)
		{
			if (!_attackReady)
			{
				_currentAttackCooldownTime =
					Mathf.Clamp(_currentAttackCooldownTime - Time.deltaTime, 0f, AttackCooldownDuration);
			}
		}
		//Is attacking, tick up attack time and check if still attacking
		_currentAttackTime = Mathf.Clamp(_currentAttackTime + Time.deltaTime, 0f,
			AttackDuration);
		_swordControlPoint.transform.eulerAngles = Vector3.Lerp(
			_slashArcBegin, _slashArcEnd, _attackCompletion);
		//print(_swordControlPoint.transform.eulerAngles);

		if (_currentAttackTime == AttackDuration)
		{
			_attacking = false;
			_swordControlPoint.SetActive(false);
		}
		#endregion

		#region Spell Update
		bool isSpell = false;

		if (isSpellActive)
		{
			spellInputTimer -= Time.deltaTime;
			if (!isSpellActive)
			{
				_spellBeingInputted = false;
				currentSpellCast = "";
				print("Input not finished in time, spell cancelled.");
			}
		}

		//No spell being cast.
		if (!_spellBeingInputted)
		{
			currentSpellCast = "";
			return;
		}
		if (_spellFinished)
		{
			_spellBeingInputted = false;
			print(currentSpellCast);
			if (spellDictionary.TryGetValue(currentSpellCast, out string spellName))
			{
				print("Casting " + spellName + " with input " + currentSpellCast);
				//cast spell
				isSpell = true;


			}
			_spellFinished = false;


			if (!isSpell)
			{
				print("No spell for this input" + currentSpellCast);
				currentSpellCast = "";
			}
			else //if it is a valid spell
			{
				currentSpellCast = "";
				spellInputTimer = 0f;
				return;
			}
		}
	#endregion
	}



	#region Attack Methods
	public bool isFirstInput()
	{
		return currentSpellCast.Length == 0;
	}

	public void OnBeginSpell(InputAction.CallbackContext context)
	{
		if (!context.performed) return;
		print("key press recognized");
		if (isFirstInput())
		{
			print("Beginning spell");
			currentSpellCast = "";
			_spellBeingInputted = true;
			spellInputTimer = SpellInputDuration;
			return;
		}

		if (_spellBeingInputted) _spellFinished = true;
	}

	public void OnSlashInput(InputAction.CallbackContext context)
	{
		if (!context.performed) return;
		HandleBasicAttack();
		bool wasSpellInput = false;
		if (!_attackReady)
		{
			currentSpellCast = currentSpellCast + "L";
			wasSpellInput = true;
			Debug.Log("attack on cooldown!");
			if (isFirstInput())
			{
				//start time frame
			}
			return;
		}
		if (!wasSpellInput)
		{
			if (isFirstInput())
			{
				//start time frame
			}
			currentSpellCast = currentSpellCast + "L";
		}
		return;
	}

	public void OnThrustInput(InputAction.CallbackContext context)
	{
		if (!context.performed) return;
		HandleBasicAttack();
		bool wasSpellInput = false;
		if (!_attackReady)
		{
			currentSpellCast = currentSpellCast + "S";
			wasSpellInput = true;
			Debug.Log("attack on cooldown!");
			if (isFirstInput())
			{
				//start time frame
			}
			return;
		}
		if (!wasSpellInput)
		{
			if (isFirstInput())
			{
				//start time frame
			}
			currentSpellCast = currentSpellCast + "S";
		}
	}

	public void OnSlamInput(InputAction.CallbackContext context)
	{
		if (!context.performed) return;
		HandleBasicAttack();
		bool wasSpellInput = false;
		if (!_attackReady)
		{
			currentSpellCast = currentSpellCast + "S";
			wasSpellInput = true;
			Debug.Log("attack on cooldown!");
			if (isFirstInput())
			{
				//start time frame
			}
			return;
		}
		if (!wasSpellInput)
		{
			if (isFirstInput())
			{
				//start time frame
			}
			currentSpellCast = currentSpellCast + "S";
		}
		return;
	}
	#endregion

	#region Helper Methods
	/// <summary>
	/// Sets up common elements between different basic attacks
	/// like setting attack cooldowns and attack duration.
	/// </summary>
	private void HandleBasicAttack()
	{
		if (!_attackReady)
		{
			Debug.Log("attack on cooldown!");
			return;
		}
		_swordControlPoint.SetActive(true);
		//Reset attack cooldown and attack duration
		_currentAttackCooldownTime = AttackCooldownDuration;
		_attacking = true;
		_currentAttackTime = 0f;

		//Lock attack direction to cardinal/diagonal
		_mostRecentAttackDirection = GetAttackDirection();
		_swordControlPoint.transform.right = GetAttackDirection();
		_slashArcBegin = _swordControlPoint.transform.eulerAngles +
			_slashArcOffset;
		_slashArcEnd = _swordControlPoint.transform.eulerAngles -
			_slashArcOffset;
		print("Attack direction: " + _mostRecentAttackDirection);
	}

	private Vector2 GetAttackDirection()
	{
		Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
		Vector2 rawAttackDirection = new Vector2(
			mousePosition.x - _swordControlPoint.transform.position.x,
			mousePosition.y - _swordControlPoint.transform.position.y);
		float rawAngle = Vector2.SignedAngle(Vector2.right, rawAttackDirection);
		Vector2 realAttackDirection;
		//EAST
		if (Mathf.Abs(rawAngle) < 22.5)
		{
			realAttackDirection = Vector2.right;
		}
		//NORTHEAST
		else if (rawAngle >= 22.5 && rawAngle < 67.5)
		{
			realAttackDirection = Vector2.right + Vector2.up;
		}
		//NORTH
		else if (rawAngle >= 67.5 && rawAngle < 112.5)
		{
			realAttackDirection = Vector2.up;
		}
		//NORTHWEST
		else if (rawAngle >= 112.5 && rawAngle < 157.5)
		{
			realAttackDirection = Vector2.up + Vector2.left;
		}
		//WEST
		else if (Mathf.Abs(rawAngle) > 157.5)
		{
			realAttackDirection = Vector2.left;
		}
		//SOUTHWEST
		else if (rawAngle >= -157.5 && rawAngle < -112.5)
		{
			realAttackDirection = Vector2.down + Vector2.left;
		}
		//SOUTH
		else if (rawAngle >= -112.5 && rawAngle < -67.5)
		{
			realAttackDirection = Vector2.down;
		}
		//SOUTHEAST
		else
		{
			realAttackDirection = Vector2.down + Vector2.right;
		}
		return realAttackDirection;
	}
	#endregion
}
